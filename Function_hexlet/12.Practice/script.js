// Реализуйте и экспортируйте функции ipToInt() и intToIp(), 
// которые преобразовывают представление IP-адреса из десятичного формата с точками 
// в 32-битное число в десятичной форме и обратно.

// Функция ipToInt() принимает на вход строку и должна возвращать число. 
// А функция intToIp() наоборот: принимает на вход число, а возвращает строку.

let ipToInt = (Ip, res = 0) => {
    let num = Ip.split('.'); //преобразую страку в массив
    //Информация по IpV4 взята из https://ru.wikipedia.org/wiki/IPv4
    //Каждый сегмент IP-адреса можно рассматривать как 8-битовое целое число без знака, то есть от 0 до 255
    res += parseInt(num[0]) * Math.pow(2, 24); //класс А адрес узла занимает — 24 бита, следовательно класс A содержит 128 подсетей по 16 777 216
    res += parseInt(num[1]) * Math.pow(2, 16); //класс B адрес узла — 16, следовательно класс B содержит 16 384 подсетей по 65 536 адресов
    res += parseInt(num[2]) * Math.pow(2, 8); //класс C адрес узла — 8 бит следовательно класс C содержит 2 097 152 сетей по 256 адресов в каждой
    res += parseInt(num[3]);
    return res; 
}
console.log(ipToInt('128.32.10.1'));// 2149583361
console.log(ipToInt('0.0.0.0')); // 0
console.log(ipToInt('255.255.255.255'));// 4294967295

let intToIp = (num) =>{
    var IPv4 = num%256; //сразу находим конечный узел
    for (var i = 3; i > 0; i--) {  //циклом перебираем и находим оставшиеся 3 узла
        num = Math.floor(num/256); //чтобы добавить оставшиеся 3 узла делим еа каждые 8 бит = 2^8 = 256;
        IPv4 = num%256 + '.' + IPv4; //добовляем с конца по одному сегменту
    }
    return IPv4;
}
console.log(intToIp(2149583361));// '128.32.10.1'
console.log(intToIp(0));// '0.0.0.0'
console.log(intToIp(4294967295));// '255.255.255.255'